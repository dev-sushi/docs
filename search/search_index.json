{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"debugging/","title":"Debugging","text":"<p>If you encounter any issues while using Lingfo, you can enable verbose mode to output extra debugging messages, which can be helpful in identifying and resolving problems.</p> <p>To enable verbose mode, update your <code>lingfo.conf</code> configuration file by changing the verbose option inside the <code>[launch]</code> section to \"yes\" and restart your application. With verbose mode enabled, Lingfo will display detailed information about its internal processes, such as function parsing.</p> <p>Example:</p> <pre><code>[launch]\nexec_command = gcc -o lib/out [file-name]\nimport_syntax = #include \"[file-name]\"\nverbose = yes\n</code></pre> <p>In addition to using verbose mode, it's recommended to check the issues for any existing solutions to your problem. If you don't find an issue related to your bug, feel free to create a new issue and provide as much information as possible to help diagnose and fix the problem.</p>"},{"location":"first-app/","title":"Our first application","text":"<p>To create a lingfo project, follow the install guide. This is required.</p>"},{"location":"first-app/#basic-steps","title":"Basic steps","text":"<p>Installing lingfo into your project is easy, you will just need to know some basics about your language to configure it (or you could find a pre-made configuration on GitHub).</p> <p>Configuration won't be covered, because it's already here. We will cover only how to use lingfo in the real world. Configuration file name: <code>lingfo.conf</code>.</p> <p>After configuring, we can move to launching lingfo for the first time. Be sure that folder <code>out/</code> (as output) is empty. If not, this folder will be automatically cleared.</p> <p>Somewhere in your Python file (recommended is the main file) import class Lingfo from the main package. Import should look like this: <code>from lingfo.main import Lingfo</code>. Lingfo class is the main class of lingfo. It won't trigger any function execution, rather just index and save functions.</p> <p>We will now need to run this, to make sure our output file (out/) is ready to use. Inside the output file, there all functions from another language be saved, so we can execute them. After running it, if everything goes well you should see files inside that output folder, which was mentioned later.</p>"},{"location":"first-app/#learning-basics-of-lingfo","title":"Learning basics of lingfo","text":""},{"location":"first-app/#running-functions","title":"Running functions","text":"<p>Let's now import our generated functions as a normal Python library. For example, if you want to import: <code>lib/main.hpp</code> just use <code>out/main.hpp</code> etc. You can now use all functions that were originally in your library, as Python functions. This guide will follow cpp example so we have only one function to use. Let's try it!</p> <p>Function name is <code>helloWorld()</code> inside <code>lib/main.hpp</code>, so the import will be <code>import out.main</code>.</p> <p>Warning</p> <p>Remember to always call your functions after Lingfo class is executed, so there won't be any conflicts.</p> <p>Inside the Python file, we just need to simply call, and run it. Output of this function will be now shown on the terminal. Congratulations! You now learned how to call simple functions, but what about classes?</p>"},{"location":"first-app/#classes","title":"Classes","text":"<p>Calling classes is the same process as calling functions. You just need to import this class and call functions from it.</p>"},{"location":"first-app/#multiple-execute","title":"Multiple execute","text":"<p>If we are using multiple functions or classes from library, it's important to use lingfo built-in support for it. Otherwise all progress will be lost on every function/class launch. To use multiple functions, import <code>MultipleExecute</code> from <code>execute</code> like so: <code>from lingfo.execute import MultipleExecute</code>. This is using Python built in with a statement, so using it looks like this: <code>with MultipleExecute():</code>, and inside that just call all your functions you need to execute.</p> <p>Before launching, be sure that you toggled <code>multiple_execute</code> to true in <code>lingfo.conf</code>. Thats it!</p>"},{"location":"first-app/#variables","title":"Variables","text":"<p>Variables, from the output side are just classes binded to python variable like this: <code>variable = LingfoVariable('variable_name', 'variable_data')</code>. To edit them, just call that class and select one of two operations: read, update. Select one of the following operations and use them as functions, like this: <code>variable.read() # or update()</code>. When updating, you can pass new value. Now, when function will be called again, variable will be updated.</p>"},{"location":"first-app/#using-lingfo-examples","title":"Using lingfo - examples","text":"<p>These examples were written in only python, you will need to get library on your own.</p>"},{"location":"first-app/#simple-usage","title":"Simple usage","text":"<p>This example will show how to use lingfo for simple use, like executing one function at the time.</p> <pre><code>from lingfo.main import Lingfo\nfrom out.example import helloWorld\nLingfo() # index our function\nhelloWorld(\"Hello, World!\") # and call it\n</code></pre>"},{"location":"first-app/#classes_1","title":"Classes","text":"<p>This example shows how to use classes. Class support is still under development, so there might be missing/broken features. Code is inherited from example above.</p> <pre><code># ... code from example: simple usage\nfrom out.example import myClass\nlingfoClass = myClass()\nlingfoClass.printHelloWorld()\n</code></pre>"},{"location":"first-app/#multiple-execute_1","title":"Multiple execute","text":"<p>Here is shown how to execute multiple functions without losing any progress. Also inherited from the first example.</p> <pre><code># ... code from example: simple usage\nfrom lingfo.execute import MultipleExecute\nfrom out.main import printHelloWorld, askForInput\nwith MultipleExecute():\nprintHelloWorld()\naskForInput()\n</code></pre>"},{"location":"first-app/#variables_1","title":"Variables","text":"<pre><code># ... code from example: simple usage\nfrom out.example import myVariable, printMyVariable\nprint(myVariable.read())\nprintMyVariable()\nmyVariable.update(\"hello, world!\")\nprintMyVariable()\n</code></pre>"},{"location":"getting-started/","title":"Installing","text":"<p>Lingfo is a library that allows you to use functions from any language, in any language (tl;dr it's foreign function interface). The goal is to eliminate wasted time when searching for new libraries when migrating to new language. Currently, it only supports language to Python but it can change in any time.</p>"},{"location":"getting-started/#getting-started","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites-and-installation","title":"Prerequisites and Installation","text":"<p>To get started with Lingfo, you need to have the following software installed on your system:</p> <ul> <li>Python 3.9 or newer</li> </ul> <p>To install the Lingfo library, you can use pip:</p> <p><code>pip install lingfo</code></p>"},{"location":"getting-started/#basic-setup-and-configuration","title":"Basic Setup and Configuration","text":"<p>Once you have installed Lingfo, you need to create a configuration file, <code>lingfo.conf</code>, in your project directory. This file will define the settings for Lingfo to work with your code.</p> <p>Here's an example lingfo.conf file for C/C++:</p> <pre><code>[main]\nlang = h\nlib_path = lib/main.h\nsafe_mode = yes # if set to yes, lingfo will alert about scripts that it will run\n[launch]\nexec_command = gcc -o lib/out [file-name]\nimport_syntax = #include \"[file-name]\"\n[temp_file]\ntemp_file = $LINGFO_IMPORT $LINGFO_NEWLINE int main() {$LINGFO_FUNCTION($LINGFO_ARGS)$LINGFO_SEMICOLON}\nextension = c\n</code></pre> <p>This configuration file defines the language, library path, compilation command, import syntax, temporary file settings, safe mode, and function pattern for your foreign language code.</p> <p><code>[main]</code>: This section specifies the language of your source code (lang) and the path to the header file containing your foreign language functions (lib_path).</p> <p><code>[launch]</code>: This section provides the command to compile your code (exec_command) and the syntax for importing the header file in the generated foreign language code (import_syntax).</p> <p><code>[temp_file]</code>: This section defines a temporary file to be used during the Lingfo processing. The temp_file value should include placeholders for the import statement, function call, and other necessary information used to compile/link your function.</p>"},{"location":"getting-started/#usage-guide","title":"Usage Guide","text":""},{"location":"getting-started/#importing-and-using-the-library","title":"Importing and Using the Library","text":"<p>To use Lingfo in your Python project, you need to import it and run it to generate the Python bindings for your foreign language code. This will automatically find all functions from library and write the functions to a Python file, so it can be executed. Here's an example Python script (app.py) that demonstrates how to use Lingfo:</p> <pre><code>from lingfopy.main import Lingfo\n\nif __name__ == \"__main__\":\n    Lingfo()\n\n    # lingfo generates code for us to call in Python\n    from out.main import itt_add , double_number\n\n    # Run a function with arguments\n    double_number(5)\n</code></pre>"},{"location":"getting-started/#running","title":"Running","text":"<p>Now let's start our program and execute our foreign language functions.</p> <p>If everything goes well, you should see this message: <code>lingfo   saving indexed functions</code>. Congratulations \ud83c\udf89 ! You are ready to use lingfo now. Just import the functions from <code>out/</code> folder that lingfo generated and call the function (e.g <code>from out.main import example</code>).</p>"},{"location":"main/","title":"Introduction","text":"<p>Lingfo is a library that allows you to run functions from other languages without needing to translate the code.</p>"},{"location":"main/#how-it-works","title":"How it works","text":"<p>Lingfo compiles or interprets the code to create a runnable file which then can be executed, displaying the output in the terminal. Removing the translation step allows for code to run at its native language speed.</p>"},{"location":"main/#the-idea","title":"The idea","text":"<p>Lingfo is a FFI that works with any language.</p> <p>In future, we want lingfo to work really from any language, to any language. To achieve this, we want to have lingfo being executed as a app when using other languages than python. So, for example, if we want to get C++ function in rust, to call the function (inside rust), the output file for lingfo would look like this:</p> <pre><code>use std::process::Command;\nfn example() {\nCommand::new(\"lingfopy\")\n.arg(\"lib/main.hpp\") // function path\n.arg(\"example\") // function name\n.arg(\"arg1, arg2, arg3\") // and some args for function to execute\n.spawn()\n.expect(\"lingfo error\");\n}\n</code></pre> <p>This might require a lot of optimization, configuration etc. But by using some not released yet lingfo apps this will be probally easier to do.</p>"},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#cache","title":"Cache","text":"<p>To make sure that we don't have to repeat the same things even if there weren't any changes, lingfo uses cache. Inside cache it saves all things like last executed code or indexed functions.</p>"},{"location":"performance/#one-time-compile","title":"One time compile","text":"<p>warning: this function is still in development</p> <p>Tired of waiting for your app to compile when changing what function to call? One time compile (as the name says) compiles the app only one time. Even when you import other function. It works by putting inside temp file some if statements with uuids to check if uuid that was passed in temp file argument match if statement uuid. If yes, it executes the function.</p> <p>Example:</p> <pre><code>if (argv[0] == \"uuid\") {example();}\nelse if (argv[1]) == \"uuid\") {nextExample();}\n</code></pre> <p>To use it, just add to configuration for <code>launch</code> section <code>one_compile = yes</code> and <code>if_statement = ...</code> <code>if_statement</code> is template for if statements that will be generated.</p> <p>Example would look like this:</p> <pre><code>if (argv[$LINGFO_ARG_NUM] == \"$LINGFO_UUID\") {$LINGFO_CODE()$LINGFO_SEMICOLON} $LINGFO_ELSE_START else if (argv[$LINGFO_ARG_NUM] == \"$LINGFO_UUID\") {$LINGFO_CODE()$LINGFO_SEMICOLON}\n</code></pre> <ul> <li><code>$LINGFO_ARG_NUM</code> = what argument number to call (e.g argv[0], argv[1])</li> <li><code>$LINGFO_UUID</code> = uuid for functions</li> <li><code>$LINGFO_CODE</code> = function that will be executed</li> <li><code>$LINGFO_SEMICOLON</code> = ;</li> <li><code>$LINGFO_ELSE_START</code> = tells lingfo that here starts else statement and if statement ends</li> </ul>"},{"location":"configuration/advanced/","title":"Advanced","text":""},{"location":"configuration/advanced/#dev-mode","title":"dev mode","text":"<p>If you are using lingfo from source, be sure to launch it by using dev mode in [index]. It will automatically generate <code>out/</code> files to work with source version of lingfo. Here's example:</p> <pre><code>[index]\ndev = yes\n</code></pre>"},{"location":"configuration/basic/","title":"Basic","text":""},{"location":"configuration/basic/#main","title":"main","text":"<p>In this section, we can configure the basics of lingfo. This includes what language your library was written in, your library path etc.</p> <p>Starting with: <code>lang</code>, you need to specify in what language your library was written.</p> <p>Note</p> <p>If your language is, for example, C++, you should not set it to <code>.cpp</code> but to <code>.hpp</code></p> <p>Next, we have <code>lib_path</code>. This is the path for your library.</p> <p>Lastly, there is <code>safe_mode</code>. Its recommended to keep this on, because when it is turned off, Lingfo won't show which scripts it will run (if, for example, extending someones config)</p>"},{"location":"configuration/basic/#launch","title":"launch","text":"<p>Launch is another important section in configuration. It provides lingfo with data on how to launch your code. Let's start with <code>exec_command</code>:</p> <p>This specifies what command to run when executing your code. For this example, we will use C++:</p> <pre><code>exec_command = gcc -o lib/out [file-name]\n</code></pre> <ul> <li>[file-name] is automatically replaced by lingfo with file path that user wants to execute, for example, if we want to execute file: <code>foo.hpp</code> from path: <code>lib/foo.hpp</code>, [file-name] will be replaced with this: <code>lib/foo.hpp</code></li> </ul> <p>Now, there is <code>import_syntax</code>. As the name says, it's just import template that lingfo will use to import function from other language. For example, once again if we want to use function from <code>lib/foo.hpp</code> the import_syntax would be (already replaced by lingfo) this:</p> <pre><code>#include &lt;foo.hpp&gt;\n</code></pre>"},{"location":"configuration/basic/#temp_file","title":"temp_file","text":"<p>Temp file section is used to tell lingfo how to manage temp file that is required to launch. Temp file for lingfo is a way to execute function from e.g C++ to python by compiling file that imported selected function.</p> <p>So, for example, if you want to execute: <code>hello()</code> in C++, the temp file would look like this:</p> <pre><code>#include \"lingfo.hpp\"\nint main() {\nhello()\n}\n</code></pre> <p>After compile the file is automatically deleted. First is: <code>temp_file</code>. This sets sturcture for our temp file. Example:</p> <pre><code>temp_file = $LINGFO_IMPORT $LINGFO_NEWLINE int main() {$LINGFO_FUNCTION($LINGFO_ARGS)$LINGFO_SEMICOLON}\n</code></pre> <p>Lets start with <code>$LINGFO_IMPORT</code>. This will be replaced with the import for selected library. <code>$LINGFO_NEWLINE</code> is just (as the name says) new line (\\n)</p> <p><code>$LINGFO_FUNCTION</code> is replaced with function to execute.</p> <p><code>$LINGFO_ARGS</code> is replaced with arguments to use. If none were passed, this will be empty.</p> <p><code>$LINGFO_SEMICOLON</code> is just a semicolon.</p> <p>As we saw, there were 2 things that usually shouldnt be here. New line and semicolon. It's because in <code>.ini</code> files its new line or comment which isnt parsed by <code>configparser</code>.</p> <p>The last thing is <code>extension</code>. Its just what file extension to use when creating temp file. Example: if using <code>C++</code>, use <code>cpp</code></p>"},{"location":"configuration/creating-templates/","title":"Creating templates","text":"<p>One way to help lingfo is to create templates. Templates are text files that are used to get rid of most configuration.</p>"},{"location":"configuration/creating-templates/#what-to-know","title":"What to know","text":"<p>Templates arent premade configurations. If you are looking to create an entire configuration, see: configuration/premade-configurations. You can only create them in official lingfo repository as a pull request.</p>"},{"location":"configuration/creating-templates/#creating","title":"Creating","text":"<p>Note</p> <p>Before continuing, you will need to know basics of git, and have this repository cloned.</p> <p>To create a language template, create a new folder in your branch and name it as your language file extension. So, for example: <code>C++</code> -&gt; <code>cpp</code> or <code>rust</code> -&gt; <code>rs</code>.</p> <p>Inside that folder, create 3 files:</p> <ul> <li>if-statement.txt</li> <li>import-syntax.txt</li> <li>temp-file.txt</li> </ul> <p>Here, we recommend to follow guide about how to create configuration for lingfo. Files are named like keys in the configurations are. After that you can create a pull request, and wait until its approved!</p>"},{"location":"configuration/premade-configurations/","title":"Premade configurations","text":"<p>Premade configurations are a great way to help lingfo and its community. If you are interested in creating one, follow these steps:</p>"},{"location":"configuration/premade-configurations/#creating","title":"Creating","text":"<p>First, create a new GitHub repository. Lingfo for now only supports premade configurations to be hosted on GitHub. Inside there, just add your configuration file from lingfo, push it and you are done. Premade configurations are just lingfo configurations downloaded from network. However, in future (when plugin support will roll out) you will be able to extend these configurations with custom python script, to enhance the user experience (of e.g customizing the configuration).</p>"},{"location":"learn/how-lingfo-works/","title":"How lingfo works - detailed","text":""},{"location":"learn/how-lingfo-works/#basics-of-lingfo","title":"Basics of lingfo","text":"<p>Lingfo compiles or interprets the code to create a runnable file which then can be executed, displaying the output in the terminal. Removing the translation step allows for code to run at its native language speed.</p>"},{"location":"learn/how-lingfo-works/#deep-look-into-lingfo","title":"Deep look into lingfo","text":"<p>Lingfo at its core, is just a simple python app. Modules like cache or one-time-compile are the things that make lingfo more interesting. But, what is hidden inside that \"simple python app\"? Few things. Let's start with the main one, which is file indexing:</p>"},{"location":"learn/how-lingfo-works/#file-indexing","title":"file indexing","text":"<p>Lingfo for file indexing uses tree-sitter, which allows to detect functions without using regex (as used before). There's not much to explain here, but here are some basics of how it works:</p> <p>First, it parses the code with tree-sitter to convert it to a tree. This tree then can be used with lingfo to get all functions from the file. After that, it grabs from these functions file name and arguments and saves it to (currently) python output file.</p>"},{"location":"learn/how-lingfo-works/#output-file","title":"output file","text":"<p>Output file is another important thing that is required to make lingfo work. Here are all functions that lingfo indexed in one file. But why do we need it? The answer is simple: we need it to execute functions. When designing lingfo, we considered 2 ways on how to execute functions:</p> <ul> <li>providing function name to Execute() function</li> <li>automatically finding file name and executing it.</li> </ul> <p>To ensure best developer experience, we choose the second option. Using that, we were able to make sure that this will be easy to use when using arguments or not, when running multiple functions etc.</p>"},{"location":"learn/what-is-oc/","title":"What is one time compile","text":"<p>warning</p> <p>This function is still in early access and might change in any time. Known issues:</p> <pre><code>- Requires manual launch (and some tweaks in lingfo code to make it work)\n- Calling functions with arguments isn't supported yet\n</code></pre> <p>One-time-compile tries to reduce the time of compilation (see: how lingfo works) by putting all functions from your selected library to if conditions. But, how do we pass what function to execute? This is quite simple. We use command line arguments. For example, if we want to launch a function, lingfo just needs to execute this to compiled file: <code>f14488e5-831a-4e7a-a25f-1c94d9de4f31</code>.</p> <p>As we saw in the example, lingfo passed UUID, not function name or function path. Thats because when first running one-time-compile or re-launching it due to edits in library (see: git tracking) lingfo assigns for every function one UUID. That UUID is being saved in cache, so lingfo can just search for function name that we want to execute and grab the UUID without creating any name conflict.</p>"}]}